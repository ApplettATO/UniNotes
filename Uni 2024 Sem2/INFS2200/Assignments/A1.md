```
--Question 1:

ALTER TABLE EVENTS ADD CONSTRAINT CK_EVENT_TYPE

    CHECK (event_type IN ('Loan', 'Return', 'Hold', 'Loss'));

  

--Question 2.1

    -- How do i end this trigger, is checking the right thing to do?

    -- is check sufficient?

CREATE OR REPLACE FUNCTION UDF_BI_GUARDIAN()

RETURNS TRIGGER AS $$

BEGIN

    IF ((CURRENT_DATE - PATRONS.dob)/365) < 18 THEN

        CHECK (NEW.guardian IS NOT NULL)

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER BI_GUARDIAN

BEFORE INSERT ON PATRONS

FOR EACH ROW

EXECUTE FUNCTION UDF_BI_GUARDIAN();

  

--Question 2.2

CREATE OR REPLACE FUNCTION UUDF_BI_EMAIL_ADDR()

RETURNS TRIGGER AS $$

BEGIN

    IF ((CURRENT_DATE - PATRONS.dob)/365) >= 18 THEN

        CHECK (NEW.email_address IS NOT NULL)

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER BI_EMAIL_ADDR

BEFORE INSERT ON PATRONS

FOR EACH ROW

EXECUTE FUNCTION UDF_BI_EMAIL_ADDR();

  

--Question 3.1

CREATE SEQUENCE ITEM_ID_SEQ

MINVALUE 1000000000

MAXVALUE 9999999999

INCREMENT BY 1

START WITH 1000000000;

  

--Question 3.2

CREATE OR REPLACE FUNCTION UDF_BI_ITEM_ID()

RETURNS TRIGGER AS $$

BEGIN

    -- need to check if null before adding to list?

    NEW.item_id := NEXTVAL('ITEM_ID_SEQ');

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER BI_ITEM_ID

BEFORE INSERT ON ITEMS

FOR EACH ROW

EXECUTE FUNCTION UDF_BI_ITEM_ID();

  

--Question 3.3

    -- double check

SELECT

    c.relname AS sequence_name,

    t.relname AS table_name,

    a.attname AS column_name

FROM

    pg_class c

JOIN

    pg_namespace n ON n.oid = c.relnamespace

JOIN

    pg_depend d ON d.objid = c.oid

JOIN

    pg_class t ON t.oid = d.refobjid

JOIN

    pg_attribute a ON a.attrelid = t.oid AND a.attnum = d.refobjsubid

WHERE

    c.relkind = 'S' -- 'S' stands for sequence

    AND t.relname IN ('PATRONS', 'EVENTS');

  

--Question 4.1

    -- double check

CREATE OR REPLACE FUNCTION UDF_BI_LOSS_CHARGE()

RETURNS TRIGGER AS $$

DECLARE

    work_cost INTEGER;

BEGIN

    SELECT cost INTO work_cost

    FROM WORKS

    WHERE isbn = (SELECT isbn FROM ITEMS WHERE item_id = NEW.item_id);

    NEW.CHARGE := work_cost;

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER BI_LOSS_CHARGE

BEFORE INSERT ON EVENTS

FOR ROW

WHEN (NEW.event_type = 'Loss')

EXECUTE FUNCTION UDF_BI_LOSS_CHARGE();

  

--Question 4.2

    -- double check

CREATE OR REPLACE FUNCTION UDF_AI_MISSING_RETURN()

RETURNS TRIGGER AS $$

DECLARE

    prev_event_id INTEGER;

    prev_patron_id INTEGER;

BEGIN

    SELECT event_id, patron_id

    INTO prev_event_id, prev_patron_id

    FROM EVENTS

    WHERE item_id = NEW.item_id

    ORDER BY time_stamp DESC

    LIMIT 1;

  

    INSERT INTO EVENTS (patron_id, item_id, event_type, time_stamp, CHARGE)

    VALUES (prev_patron_id, NEW.item_id, 'RETURN', NEW.time_stamp - INTERVAL '1 hour', 0);

  

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER AI_MISSING_RETURN

AFTER INSERT ON EVENTS

FOR ROW

WHEN (NEW.event_type = 'BORROW' AND EXISTS (

    SELECT 1 FROM EVENTS

    WHERE item_id = NEW.item_id

    AND event_type = 'BORROW'

    AND patron_id <> NEW.patron_id

    AND time_stamp < NEW.time_stamp

    AND NOT EXISTS (

        SELECT 1 FROM EVENTS

        WHERE item_id = NEW.item_id

        AND event_type = 'RETURN'

        AND patron_id = (

            SELECT patron_id

            FROM EVENTS

            WHERE item_id = NEW.item_id

            AND event_type = 'BORROW'

            AND time_stamp < NEW.time_stamp

            ORDER BY time_stamp DESC

            LIMIT 1

        )

    )

))

EXECUTE FUNCTION UDF_AI_MISSING_RETURN();

  

--Question 4.3

    -- double check

CREATE OR REPLACE FUNCTION UDF_BI_HOLDS()

RETURNS TRIGGER AS $$

DECLARE

    item_on_loan BOOLEAN;

    loan_timestamp TIMESTAMP;

BEGIN

    SELECT EXISTS (

        SELECT 1 FROM EVENTS

        WHERE item_id = NEW.item_id

        AND event_type = 'Borrow'

        AND time_stamp > NEW.time_stamp

        AND NOT EXISTS (

            SELECT 1 FROM EVENTS

            WHERE item_id = NEW.item_id

            AND event_type = 'Return'

            AND time_stamp > NEW.time_stamp

        )

    ), (

        SELECT time_stamp

        FROM EVENTS

        WHERE item_id = NEW.item_id

        AND event_type = 'Borrow'

        ORDER BY time_stamp DESC

        LIMIT 1

    ) INTO item_on_loan, loan_timestamp;

  

    IF EXISTS (

        SELECT 1 FROM EVENTS

        WHERE item_id = NEW.item_id

        AND event_type = 'Hold'

        AND patron_id <> NEW.patron_id

        AND time_stamp > NEW.time_stamp

    ) THEN

        RETURN NULL;

    END IF;

  

    IF item_on_loan THEN

        NEW.time_stamp := loan_timestamp + INTERVAL '42 days';

    ELSE

        NEW.time_stamp := NEW.time_stamp + INTERVAL '14 days';

    END IF;

  

    RETURN NEW;

END;

$$ LANGUAGE plpgsql;

  

CREATE TRIGGER BI_HOLDS

BEFORE INSERT ON EVENTS

FOR ROW

WHEN (NEW.event_type = 'Hold')

EXECUTE FUNCTION UDF_BI_HOLDS();
```